"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inlineResources = exports.elementToSVG = exports.documentToSVG = void 0;

const dom_1 = require("./dom");

const traversal_1 = require("./traversal");

const stacking_1 = require("./stacking");

const util_1 = require("./util");

const css_1 = require("./css");

const postcss_value_parser_1 = __importDefault(require("postcss-value-parser"));

function documentToSVG(document, options) {
  return elementToSVG(document.documentElement, options);
}

exports.documentToSVG = documentToSVG;

function elementToSVG(element, options) {
  var _options$captureArea, _options$captureArea2;

  const svgDocument = element.ownerDocument.implementation.createDocument(dom_1.svgNamespace, 'svg', null);
  const svgElement = svgDocument.documentElement;
  svgElement.setAttribute('xmlns', dom_1.svgNamespace);
  svgElement.setAttribute('xmlns:xlink', dom_1.xlinkNamespace);
  svgElement.append(svgDocument.createComment( // "--" is invalid in comments, percent-encode.
  ` Generated by dom-to-svg from ${element.ownerDocument.location.href.replace(/--/g, '%2D%2D')} `)); // Copy @font-face rules

  const styleElement = svgDocument.createElementNS(dom_1.svgNamespace, 'style');

  for (const styleSheet of element.ownerDocument.styleSheets) {
    let rules;

    try {
      rules = styleSheet.rules;
    } catch (error) {
      console.error('Could not access rules of styleSheet', styleSheet, error);
    } // Make font URLs absolute (need to be resolved relative to the stylesheet)


    for (const rule of (_rules = rules) !== null && _rules !== void 0 ? _rules : []) {
      var _rules, _rule$parentStyleShee;

      if (!css_1.isCSSFontFaceRule(rule)) {
        continue;
      }

      const styleSheetHref = (_rule$parentStyleShee = rule.parentStyleSheet) === null || _rule$parentStyleShee === void 0 ? void 0 : _rule$parentStyleShee.href;

      if (styleSheetHref) {
        const parsedSourceValue = postcss_value_parser_1.default(rule.style.src);
        parsedSourceValue.walk(node => {
          if (node.type === 'function' && node.value === 'url' && node.nodes[0]) {
            const urlArgumentNode = node.nodes[0];

            if (urlArgumentNode.type === 'string' || urlArgumentNode.type === 'word') {
              urlArgumentNode.value = new URL(css_1.unescapeStringValue(urlArgumentNode.value), styleSheetHref).href;
            }
          }
        });
        rule.style.src = postcss_value_parser_1.default.stringify(parsedSourceValue.nodes);
      }

      styleElement.append(rule.cssText, '\n');
    }
  }

  svgElement.append(styleElement);
  traversal_1.walkNode(element, {
    svgDocument,
    currentSvgParent: svgElement,
    stackingLayers: stacking_1.createStackingLayers(svgElement),
    parentStackingLayer: svgElement,
    getUniqueId: util_1.createIdGenerator(),
    labels: new Map(),
    ancestorMasks: [],
    options: {
      captureArea: (_options$captureArea = options === null || options === void 0 ? void 0 : options.captureArea) !== null && _options$captureArea !== void 0 ? _options$captureArea : element.getBoundingClientRect(),
      keepLinks: (options === null || options === void 0 ? void 0 : options.keepLinks) !== false
    }
  });
  const bounds = (_options$captureArea2 = options === null || options === void 0 ? void 0 : options.captureArea) !== null && _options$captureArea2 !== void 0 ? _options$captureArea2 : element.getBoundingClientRect();
  svgElement.setAttribute('width', bounds.width.toString());
  svgElement.setAttribute('height', bounds.height.toString());
  svgElement.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
  return svgDocument;
}

exports.elementToSVG = elementToSVG;

var inline_1 = require("./inline");

Object.defineProperty(exports, "inlineResources", {
  enumerable: true,
  get: function () {
    return inline_1.inlineResources;
  }
});